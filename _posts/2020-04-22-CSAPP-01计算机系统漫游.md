---
layout:     post
title:      "CSAPP-01计算机系统漫游"
date:       2020-04-22 22:00:00
author:     "SH"
header-img: "img/CSAPP/冯诺依曼体系结构.png"
header-mask: 0.3
catalog:    true
tags:
    - CSAPP
---


# CSAPP-01计算机系统漫游
hello.c 程序：
```c
#include <stdio.h>

int main()
{
	printf("hello, world\n");
	return 0;
}
```

## 1）信息就是位+上下文

源程序实际上就是一个由值0和1组成的位（比特）序列，8个位被组织成一组，成为字节。

ASCII文本表示：

<img src="/img/CSAPP/CSAPP-01-hello.c的ASCII文本表示.png" alt="image-20210104103016220" style="zoom: 50%;" />

基本思想：

系统中的所有信息----包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串**比特**表示的。区分不同数据对象的唯一方法就是读到这些数据对象的**上下文**。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

## 2）程序被其他程序翻译成不同的格式

在Unix系统上，从源文件到目标文件的转化是由*编译器驱动程序*完成的：

```shell
linux> gcc -o hello hello.c
```

GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可以分为四个阶段完成，预处理器、编译器、汇编器和链接器，一起构成了编译系统。

![image-20210104112528379](/img/CSAPP/CSAPP-01-编译系统.png)

- **预处理阶段。**预处理器根据以字符#开头的命令，修改原始的C程序。比如hello.c中第一行的 #include <stdio.h> 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到另一个C程序，通常以 .i 作为文件扩展名。
- **编译阶段。**编译器将文件文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。
- **汇编阶段。**汇编器将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件 hello.o 中。hello.o文件是一个二进制文件。
- **链接阶段。**hello程序调用了 printf 函数，它是每个C编译器都提供的标准C库中的一个函数，printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到 hello.o 程序中。连接器就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。

## 3）编译系统如何工作

依靠编译系统可以生成正确有效的机器代码，但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。

- **优化程序性能：**
  - switch语句是否总是比一系列的if-else语句高效得多？
  - 一个函数调用的开销有多大？
  - while循环比for循环更有效吗？
  - 指针引用比数组索引更有效吗？
  - 为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？
  - 为什么只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？
  - 关注：
    - 编译器是怎样把不同的C语言结构翻译成机器语言的；
    - 简单转换代码从而调整C程序的性能；
    - 存储系统的层次结构特性，如何将数组存放在内存中。
- **理解链接时出现的错误：**
  - 链接器报告说它无法解析一个引用，是什么意思？
  - 静态变量和全局变量的区别是什么？
  - 在不同的C文件中定义了同名的两个全局变量会发生什么？
  - 静态库和动态库的区别是什么？
  - 在命令行上排列库的顺序有什么影响？
  - 为什么有些链接错误直到运行时才会出现？
- 避免安全漏洞：
  - **堆栈原理和缓冲区溢出错误；**
  - 理解数据和控制信息存储在程序栈上的方式。

## 4）处理器读并解释储存在内存中的指令

hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello，并存储在磁盘上。要想在Unix系统上运行该文件，可以输入shell应用程序中：

```shell
linux> ./hello
hello, world
linux>
```

### 系统的硬件组成

<img src="/img/CSAPP/CSAPP-01-一个典型系统的硬件组成.png" alt="image-20210104114906384" style="zoom:50%;" />

#### （1）总线

**贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。**

通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。大多数机器字长：

- 4个字节（32位）
- 8个字节（64位）

#### （2）I/O设备

**I/O（输入/输出）设备是系统与外部世界的联系通道。**

- 作为用户输入的键盘和鼠标；
- 作为用户输出的显示器；
- 用于长期存储数据和程序的磁盘驱动器（就是磁盘）。

**每个I/O设备都通过一个控制器或适配器与I/O总线相连。**

控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（主板）上的芯片组，而适配器则是一块插在主板插槽上的卡。

#### （3）主存

**主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。**

- 从物理上来说，主存是由一组**动态随机存取存储器（DRAM）**芯片组成的。
- 从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。

#### （4）处理器

**中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。**

处理器的核心是一个**大小为一个字的存储设备（或寄存器）**，称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。

从系统通电开始，直到系统断电，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由**指令集架构**决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。

**寄存器文件（register file）**：一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。

**算术/逻辑单元（ALU）**：计算新的数据和地址值。

CPU在指令的要求下可能会执行这些操作：

- **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
- **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
- **操作**：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
- **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。

需要将处理器的**指令集架构**和处理器的**微体系结构**区分开来：

- 指令集架构提供的抽象性：指令集架构描述的是每条机器代码指令的效果；
- 处理器实际如何实现：微体系结构描述的是处理器实际上是如何实现的。

### 运行hello程序

初始时，shell 程序执行它的指令，等待输入一个命令。当在键盘上输入字符串“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到内存中。

<img src="/img/CSAPP/CSAPP-01-运行hello程序1_从键盘上读取hello命令.png" alt="image-20210104192847444" style="zoom:50%;" />

当再键盘上敲回车键时，shell 程序就知道已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello, world\n”。

利用**直接存储器存取（DMA）**技术，数据可以不通过处理器而直接从磁盘到达主存。

<img src="/img/CSAPP/CSAPP-01-运行hello程序2_从磁盘加载可执行文件到主存.png" alt="image-20210104193215404" style="zoom:50%;" />

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将“hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

<img src="/img/CSAPP/CSAPP-01-运行hello程序3_将输出字符串从存储器写到显示器.png" alt="image-20210104193435468" style="zoom:50%;" />

## 5）高速缓存至关重要

以上示例揭示了一个重要问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

针对处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，**高速缓存存储器（cache memory）**，作为**暂时的集结区域**，**存放处理器近期可能会需要的信息。**

<img src="/img/CSAPP/CSAPP-01-高速缓存存储器.png" alt="image-20210104194215968" style="zoom:50%;" />

- 位于处理器芯片上的 L1 高速缓存的容量可以达到**数万字节**，访问速度几乎和访问寄存器文件一样快。
- 一个容量为**数十万到数百万字节**的更大的 L2 高速缓存通过一条特殊的总线连接到处理器。
- 进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长5倍，但是仍然比访问主存的时间快5~10倍。
- L1 和 L2 高速缓存是用一种叫做**静态随机访问存储器（SRAM）**的硬件技术实现的。
- 比较新的、处理能力更强大的系统甚至有三级高速缓存 L3。
- 系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即**程序具有访问局部区域里的数据和代码的趋势**。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中文件。

## 6）存储设备形成层次结构

<img src="/img/CSAPP/CSAPP-01-存储器层次结构.png" alt="image-20210104200040105" style="zoom:50%;" />

## 7）操作系统管理硬件

可以把操作系统看成是应用程序和硬件之间插入的一层软件。

<img src="/img/CSAPP/CSAPP-01-计算机系统的分层视图.png" alt="image-20210104200215421" style="zoom:50%;" />

操作系统有两个基本功能：

（1）防止硬件被失控的应用程序滥用；

（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念来实现这两个功能：**进程**、**虚拟内存**、**文件**。

<img src="/img/CSAPP/CSAPP-01-操作系统提供的抽象表示.png" alt="image-20210104200455606" style="zoom:50%;" />

- 文件是对 I/O 设备的抽象表示；
- 虚拟内存是对主存和磁盘 I/O 设备的抽象表示；
- 进程是对处理器、主存和 I/O 设备的抽象表示。

### 进程

像 hello 这样的程序在现代系统上运行时，操作系统会提供一种**假象**，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令。这些假象是通过进程的概念来实现的，**进程是计算机科学中最重要和最成功的概念之一**。

**进程是操作系统对一个正在运行的程序的一种抽象。**

一个CPU看上去像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。称为**上下文切换**。

操作系统保持跟踪进程运行所需的所有状态信息，这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。

### 线程

一个进程实际上可以由多个称为线程的执行单元组成，**每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。**

由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。

### 虚拟内存

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到地内存都是一致的，称为**虚拟地址空间**。

在Linux中地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。

<img src="/img/CSAPP/CSAPP-01-进程的虚拟地址空间.png" alt="image-20210104203104657" style="zoom:50%;" />

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- **程序代码和数据。**对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，如示例中的 hello。（链接和加载时会有更多有关地址空间的内容）。
- **堆。**代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。
- **共享库。**共享库的概念非常强大，也相当难懂。（动态链接部分学习）。
- **栈。**位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。
- **内核虚拟内存。**地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译，**基本思想就是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。**

### 文件

**文件就是字节序列，仅此而已。**

## 8）系统之间利用网络通信

从一个单独的系统来看，网络可视为一个 I/O 设备。

<img src="/img/CSAPP/CSAPP-01-网络也是一种IO设备.png" alt="image-20210104204423190" style="zoom:50%;" />



## 9）重要主题

### Amdahl定律

当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。
$$
T_{new} = (1 - 	\alpha) T_{old} + (\alpha T_{old}) / k = T_{old}[(1 - \alpha) + \alpha/k]
$$
加速比 
$$
S = T_{old} / T_{new} = \frac{1}{(1-\alpha) + \alpha/k}
$$
Amdahl定律的主要观点：**要想显著加速整个系统，必须提升全部系统中相当大的部分的速度。**

### 并发和并行

计算机的整个历史中，有两个需求是驱动进步的持续动力：

- 一个是想要计算机做得**更多**；
- 另一个是想要计算机运行得**更快**。

两个概念：

- **并发（concurrency）**：是一个通用的概念，指一个同时具有多个活动的系统；
- **并行（parallelism）**：指的是用并发来使一个系统运行得更快。

#### （1）线程级并发

#### （2）指令级并行

#### （3）单指令、多数据并行



### 计算机系统中抽象的重要性

<img src="/img/CSAPP/CSAPP-01-操作系统提供的抽象表示2.png" alt="image-20210104204758943" style="zoom:50%;" />

在处理器里，**指令集架构**提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序地模型保持一致。只要执行模型一样，不同地处理器实现也能执行同样地机器代码，而又提供不同的开销和性能。

操作系统中，**文件**是对 I/O 设备的抽象，**虚拟内存**是对程序存储器的抽象，而**进程**是对一个正在运行的程序的抽象。

**虚拟机**，提供对整个计算机的抽象，包括操作系统、处理器和程序。



## 10）没有操作系统时如何操控计算机

- [早期没有操作系统时人们是如何操控计算机的？](https://www.zhihu.com/question/21751451)